#' Connecting Community between predicted time points
#' @description \code{community_connect()} constructs connections of communities
#' between all predicted time points.
#' @param group_label a list of length \code{npred}, where \code{npred} is the number of
#' predicted time points. Each element in the list is a dataframe containing
#' genes' community belongings in one predicted time point. This list
#' could be generated by function \code{\link{gene_community_detection}}.
#'
#' @return a list of length \code{npred-1}. The \code{i}-th element in the list is a
#' dataframe which the first column is community id in the \code{i}-th predicted
#' time point and the second column is the corresponding community in the \code{(i+1)}-th
#' predicted time point. Community in the \code{(i+1)}-th time point which shares the
#' most common genes with community in the \eqn{i}-th time point is regraded as
#' corresponding community.
#' @export
#'

community_connect = function(group_label){
  community_connect1 = list()
  l = length(group_label)-1
  for (kk in 1:l){
    temp_net = group_label[[kk]]
    temp2_net = group_label[[kk+1]]
    n = nlevels(factor(temp_net$group))
    data_connect = data.frame(source = NULL, target = NULL)

    for (ii in 1:n){
      num = c()
      subset1 = temp_net[temp_net$group == ii, ]
      v1 = subset1$gene
      n2 = nlevels(factor(temp2_net$group))
      for (jj in 1:n2){
        subset2 = temp2_net[temp2_net$group == jj, ]
        v2 = subset2$gene
        inter = intersect(v1,v2)
        if (length(inter) > 1){
          num = c(num,length(inter))
        } else {
          num = c(num, -1)
        }
      }
      max_gene = which.max(num)
      if (num[max_gene] > 1){
        pp = data.frame(source = ii, target = max_gene)
        data_connect = rbind(data_connect, pp)
      }
    }
    community_connect1[[kk]] = data_connect
  }
  return(community_connect1)
}
