#' Dynamic linear relationship between genes
#' @description \code{dynamic_linear_relationship()} calculates dynamic strength of
#' pairwise-gene linear relationship, using functional concurrent linear model and
#' smoothing spline ANOVA model.
#' @param data a dataframe with \eqn{N*t} rows and \eqn{d+2} columns, where \eqn{N} is
#' the number of cells in one time point(the number of cells need to be equal
#' among different time points),
#' \eqn{t} is the number of time points, \eqn{d} is the number of genes. The first column
#' is the cell names and the last column is the time points which contains continuous
#' integers beginning from 1. The column names of the first and the last columns need to be set as
#' 'index' and 'time', respectively.
#' This dataframe could be regraded as a result of \code{rbind()} of cell-gene
#' dataset ordered by \emph{increasing} time points.
#' @param gene_expression a list of length \eqn{d}, where \eqn{d} is the number of genes. The elements
#' in the list representing the individual gene expression in \eqn{N} cell
#' lineages trajectories, each trajectory has \eqn{t} time points. This list
#' could be generated by function \code{\link{gene_expression}}.
#' @param alpha a parameter used in SSANOVA.Larger absolute values yield smoother fits.
#' See \code{\link[gss]{ssanova}} for details.
#' @param npred the number of predicted time points equally spaced
#' between 1 and \eqn{t}.
#'
#' @return a dataframe containing strength of pairwise-gene linear relationship in
#' each predicted time points.
#' @export
#'

dynamic_linear_relationship = function(data,gene_expression,alpha=0.3,npred=101){
  ## correlation
  nTime = max(data$time)
  nTime_seq = seq(1:nTime)
  time = list()
  for (ii in 1:nTime){
    temp = data[data$time == ii,]
    temp = data.frame(temp, row.names = 1)
    temp = t(temp[,-c(ncol(temp))])
    corr = gcn(temp)
    time[[ii]] = corr
  }

  ltemp = length(names(data))
  name = names(data)[-c(1,ltemp)]
  gene_name = names(data)[-c(1,ltemp)]
  res = subsets(length(name),2)
  mse_all = c()
  #name = gene_name
  fit_fit = list()
  names_name = c()
  pb <- progress_bar$new(
    format = 'Processing [:bar] :percent eta: :eta',
    total = nrow(res), clear = FALSE, width = 80)
  for (jj in 1:nrow(res)){
    ###### true ##########
    pb$tick()
    gene_gene = res[jj,]
    gene = c(gene_name[gene_gene[1]], gene_name[gene_gene[2]])
    rho = c()
    for (i in 1:nTime){
      temp = time[[i]]
      name1 = gene[1]
      name2 = gene[2]
      sub = subset(temp, rownames(temp) %in% name1)
      value = sub[, name2]
      rho = c(rho,value)
    }
    ss = data.frame(x = nTime_seq, y = rho)
    fitss = ssanova(y~x, data = ss,alpha = alpha)
    hh = data.frame(x = seq(1,nTime,length = npred))
    est_true = predict(fitss, newdata = hh)
    ###### Estimate
    gene1 = gene_expression[[gene_gene[1]]]
    gene2 = gene_expression[[gene_gene[2]]]

    K = nTime #num of time points
    xdomain = c(0,20)

    #sigma = 0.5
    pt = c()
    wt = c()
    for (i in 1:ncol(biotime)){
      t.i = biotime[,i]
      w.i = weight.nodes(t.i,xdomain)
      pt = c(pt,t.i)
      wt = c(wt,w.i)
    }
    quad = list(pt=pt,wt=wt)
    yqlist <- split(as.matrix(gene1), seq(nrow(gene1)))
    xqlist <- split(as.matrix(gene2), seq(nrow(gene2)))


    tryCatch({
      fit = flr2d(yqlist,xqlist,quad,method="v",alpha=alpha,id.basis=2*c(1:K),xdomain=xdomain)
      tgrid = seq(1,nTime, length = npred)
      est0 <- estimate.flr2d(fit,tgrid,se=TRUE)
      fit_fit[[jj]] = est0$fit
      names_name = c(names_name, paste0(name[gene_gene[1]],"_",name[gene_gene[2]]))
    }, error=function(e){cat("ERROR :",conditionMessage(e), "\n")})
    #print(gene_name)
    #print(jj)
  }
  names(fit_fit) = names_name
  mucl <- data.frame(matrix(unlist(fit_fit), nrow=length(fit_fit), byrow=TRUE))
  rownames(mucl) = names_name
  return(mucl)
}
