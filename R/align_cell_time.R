#' Align cell time
#' @description \code{align_cell_time()} normalizes the time line since different
#' cells need different time in the differentiate process.
#' @param trajectory_expression a list of length \eqn{N},where \eqn{N} is
#' the number of cells in one time point(the number of cells need to be equal
#' among different time points). The \eqn{i}-th element in the list is a matrix with
#' \eqn{d} rows and \eqn{t} columns, giving the gene expression of \eqn{d} genes in \eqn{t} time
#' points of the \eqn{i}-th cell lineages trajectory. This list
#' could be generated by function \code{\link{trajectory_expression}}.
#'
#' @return a matrix of aligned cell time.
#' @export


align_cell_time = function(trajectory_expression){
  nTime = length(trajectory_expression[[1]][1,])
  #nTime = max(total$time)
  #### Find cell means
  gene_mean_cell = lapply(trajectory_expression, function(x){colMeans(x)})
  gene_mean_cell = data.frame(matrix(unlist(gene_mean_cell), nrow=length(gene_mean_cell), byrow=TRUE))

  ###### register time
  nTime_seq = seq(1:ncol(gene_mean_cell))

  hgtf   = t(gene_mean_cell)
  ncasef = dim(hgtf)[2]

  growbasis = create.bspline.basis(nTime_seq, norder=3)
  growfdPar = fdPar(growbasis,lambda = 0.1)
  growthMon = smooth.basis(nTime_seq, hgtf, growfdPar)
  hgtfhatfd = growthMon$fd

  nwbasisCR = 6
  norderCR  =  3
  wbasisCR  = create.bspline.basis(c(1,nTime), nwbasisCR, norderCR)
  Wfd0CR    = fd(matrix(0,nwbasisCR,ncasef),wbasisCR)
  lambdaCR  = 0.01
  WfdParCR  = fdPar(Wfd0CR, 1, lambdaCR)

  registerlistCR = register.fd(yfd = hgtfhatfd,WfdParobj = WfdParCR)
  regist = registerlistCR$regfd

  biotime = eval.fd(c(1:nTime),registerlistCR$warpfd)
  return(biotime)
}
